from random import randint, choice
from copy import deepcopy


class SudokuGrid():
	'''
	Sudoku board.
	Attributes:
	width = size of the board - defaults to 3.
	rows = List of 9 lists of 9 values. The root from which the grid is built.
	cols = List of 9 lists of 9 values. Derived from rows.
	regions = List of 9 lists of 9 values. Derived from rows.
	coordrows and coorcols and coordregs = Same as above but stores the coordinates of each cell in tuple form.
	coord_dict = Dictionary of coordinates (keys) and values.
	Standalone methods:
	print_grid(): Prints the grid to the console, taking the rows attribute as argument.
	printable_coords(): Returns a list of rows where the values have been replaced by their coordinates
		in symmetric fashion. Pass it to the method above to have a pretty grid of coordinates printed.
	populate_grid(): Populates the grid with the argument passed- usually a character.
		Optionally accepts 'rand' to randomize the board (ignoring sudoku rules) or 'clear' to clear it.
	'''

	def __init__(self, width=3, **kwargs):
		self.width = width
		self.rows = self.build_rows(defval='')

		self.last_valid_region = 0

	def build_rows(self, defval='', args=[], kwargs={}):
		'''
		Builds a list of x rows (x=width*3). Populates cells with empty string by default,
		but function can be called with a different function, such as randint(1,9).
		In this case, the function has to be called like this: self.build_rows(defval=randint,args=[1,9])
		'''	
		w = self.width*3
		rowlist = [[list() for i in range(w)] for i in range(w)]
		for r in range(w):
			for c in range(w):
				try:
					rowlist[r][c] = defval(*args, **kwargs)
				except:
					rowlist[r][c] = defval

		self.rows = rowlist
		self.cols = self.build_cols(rowlist)
		self.regions = self.build_regions(rowlist)
		self.coordrows, self.coordcols, self.coordregs = self.build_coords(rowlist)
		self.coord_dict = self.build_coord_dict()
		return rowlist

	def build_cols(self, rows):
		'''
		Builds a list of x columns (x=width*3) from the rows generated by the above method. Used when building the grid coordinates.
		'''		
		colslist = []
		for col in range(self.width*3): #initializes list of cols
			colslist.append([])
		for row in rows:
			colindex = 0
			for col in row:
				colslist[colindex].append(col)
				colindex += 1
		return colslist

	def build_regions(self, rows):
		reglist = [list() for _ in range(len(rows))] 
		for i in range(0,9,3):
			for row in rows[i:i+3]:
				x = 0
				for I in range(3):
					reglist[I+i].extend(row[x:x+3])
					x += 3
		return reglist

	def build_coords(self, rows): 
		'''
		Replaces the values populated on the grid by their coordinates. Returns a list of rows containing tuple pairs..
		'''
		rowscopy = deepcopy(rows)
		colscopy = self.build_cols(rowscopy)
		

		for row in rowscopy:
			for item in row:
				newtuple = tuple()
				icol = row.index(rowscopy[rowscopy.index(row)][row.index(item)])
				irow = rowscopy.index(row)
				newtuple = irow, icol
				rowscopy[rowscopy.index(row)][row.index(item)] = newtuple
		
		coordcols = self.build_cols(rowscopy)
		coordregs = self.build_regions(rowscopy)

		return rowscopy, coordcols, coordregs

	def printable_coords(self): 
		'''
		Replaces the values populated on the grid by their coordinates. Returns a list of rows - much like build_rows().
		For widths or heights larger than 3, zeroes are inserted before the relevant coordinates to ensure symmetry.
		'''
		rowscopy = deepcopy(self.rows)
		colscopy = self.build_cols(rowscopy)
		max_irow_len = len(str(self.width*3))
		max_icol_len = len(str(self.width*3))
		for row in rowscopy:
			for item in row:
				icol = str(row.index(rowscopy[rowscopy.index(row)][row.index(item)]))
				while len(icol) < max_icol_len:
					icol = '0' + icol
				irow = str(rowscopy.index(row))
				while len(irow) < max_irow_len:
					irow = '0' + irow
				rowscopy[rowscopy.index(row)][row.index(item)] = irow + icol

		return rowscopy

	def build_coord_dict(self):
		'''
		Builds a list of dictionaries where keys are the coordinates built by build_coords(),
		and values are the actual values originally populated on the grid. Each dictionary corresponds to one region.
		'''
		w = self.width*3
		coord_dict_reglist = []
		for i in range(w):
			d = dict(zip(self.coordregs[i], self.regions[i]))
			coord_dict_reglist.append(d)
		return coord_dict_reglist


	def print_grid(self, rows):
		'''
		Pretty prints the grid using a list of rows.
		'''
		rowstr = ''.join(map(str, rows[0]))
		cellen = len(rowstr)//(self.width*3)
		regsep = ('+' + ('-'*(cellen*3)) + ('----'))*self.width + '+'

		print(regsep)
		for y in range(0,self.width*3,3):
			for row in rows[y:y+3]:
				print('| ', end='')
				for x in range(0,self.width*3,3):
					print(*row[x:x+3], '| ', end='')
				print('')
			print(regsep)

	def populate_grid(self, val='rand'):
		'''Populates the grid. Accepts one character
		or the keywords 'rand' (randomizes grid, the default) and 'clear' (clears grid).
		'''
		if val == 'rand':
			self.build_rows(defval=randint,args=[1,9])
			self.print_grid(self.rows)
		elif val == 'clear':
			self.build_rows(defval='')
			self.print_grid(self.rows)
		else:
			self.build_rows(defval=val)
			self.print_grid(self.rows)

	def pop_valid_board(self, first_time=True):
		if first_time:
			self.populate_grid('')
		for i, dic in enumerate(self.coord_dict):
			if i < self.last_valid_region:
				continue
			if i == self.last_valid_region:
				for r, c in self.coord_dict[i].keys():
					self.rows[r][c] = ''
					self.cols = self.build_cols(self.rows)
					self.regions = self.build_regions(self.rows)
					self.coordrows, self.coordcols, self.coordregs = self.build_coords(self.rows)
					self.coord_dict = self.build_coord_dict()
				for r, c in self.coord_dict[i+1].keys():
					self.rows[r][c] = ''
					self.cols = self.build_cols(self.rows)
					self.regions = self.build_regions(self.rows)
					self.coordrows, self.coordcols, self.coordregs = self.build_coords(self.rows)
					self.coord_dict = self.build_coord_dict()
				for r, c in self.coord_dict[i+2].keys():
					self.rows[r][c] = ''
					self.cols = self.build_cols(self.rows)
					self.regions = self.build_regions(self.rows)
					self.coordrows, self.coordcols, self.coordregs = self.build_coords(self.rows)
					self.coord_dict = self.build_coord_dict()				

			for r, c in dic.keys():
				valids = [number for number in range(1,self.width*3+1)]
				while True:
					try:
						n = choice(valids)
					except IndexError:
						self.last_valid_region = i-2
						if self.last_valid_region < 0:
							self.last_valid_region = 0
						print(f'Oops, no more valid numbers for region {i}. Restarting from region: {i-2}')
						self.pop_valid_board(first_time=False)
						return
						
					if n in (self.rows[r]+self.cols[c]+self.regions[i]):
						valids.remove(n)
						continue
					else:
						self.rows[r][c] = n
						self.cols = self.build_cols(self.rows)
						self.regions = self.build_regions(self.rows)
						self.coordrows, self.coordcols, self.coordregs = self.build_coords(self.rows)
						self.coord_dict = self.build_coord_dict()
						self.print_grid(self.rows)
						break






			

t = SudokuGrid()


t.pop_valid_board()



	











